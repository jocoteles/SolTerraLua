"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RealityAccelerator = void 0;
const Anchor_1 = require("./Anchor");
const three_1 = require("three");
const HitTestTarget_1 = require("./HitTestTarget");
const Plane_1 = require("./Plane");
const Mesh_1 = require("./Mesh");
const TransformObject_1 = require("./TransformObject");
class RealityAccelerator {
    _xrManager;
    _planes;
    _meshes;
    _anchors;
    _hitTestTargets;
    _root;
    constructor(xrManager) {
        this._xrManager = xrManager;
        this._planes = new Set();
        this._meshes = new Set();
        this._anchors = new Set();
        this._hitTestTargets = new Set();
        this._root = new three_1.Group();
    }
    get root() {
        return this._root;
    }
    get planes() {
        return this._planes;
    }
    get meshes() {
        return this._meshes;
    }
    get anchors() {
        return this._anchors;
    }
    get hitTestTargets() {
        return this._hitTestTargets;
    }
    get persistentAnchors() {
        return new Set(Array.from(this._anchors).filter((anchor) => anchor.isPersistent));
    }
    onPlaneAdded;
    onPlaneDeleted;
    onMeshAdded;
    onMeshDeleted;
    update() {
        if (!this._xrManager.isPresenting)
            return;
        const frame = this._xrManager.getFrame();
        this._checkPlaneDiff(frame);
        this.planes.forEach((plane) => {
            (0, Plane_1.updatePlane)(plane, this._xrManager);
        });
        this._checkMeshDiff(frame);
        this.meshes.forEach((mesh) => {
            (0, Mesh_1.updateMesh)(mesh, this._xrManager);
        });
        this.anchors.forEach((anchor) => {
            (0, TransformObject_1.updateTransformObject)(anchor, this._xrManager);
        });
        this._hitTestTargets.forEach((hitTestTarget) => {
            (0, HitTestTarget_1.updateHitTestTarget)(hitTestTarget, this._xrManager);
        });
    }
    _checkPlaneDiff(frame) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        const detectedPlanes = frame.detectedPlanes;
        const newXrPlanes = [];
        detectedPlanes.forEach((xrPlane) => {
            let match = false;
            this._planes.forEach((plane) => {
                if (plane.xrPlane === xrPlane)
                    match = true;
            });
            if (!match)
                newXrPlanes.push(xrPlane);
        });
        const deletedPlanes = [];
        this._planes.forEach((plane) => {
            if (!detectedPlanes.has(plane.xrPlane)) {
                deletedPlanes.push(plane);
            }
        });
        newXrPlanes.forEach((xrPlane) => {
            const plane = new Plane_1.Plane(xrPlane);
            (0, Plane_1.updatePlane)(plane, this._xrManager);
            this._root.add(plane);
            if (this.onPlaneAdded) {
                this.onPlaneAdded(plane);
            }
            this._planes.add(plane);
        });
        deletedPlanes.forEach((plane) => {
            if (this.onPlaneDeleted) {
                this.onPlaneDeleted(plane);
            }
            this._root.remove(plane);
            this._planes.delete(plane);
        });
    }
    _checkMeshDiff(frame) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        const detectedMeshes = frame.detectedMeshes;
        const newXrMeshes = [];
        detectedMeshes.forEach((xrMesh) => {
            let match = false;
            this._meshes.forEach((mesh) => {
                if (mesh.xrMesh === xrMesh)
                    match = true;
            });
            if (!match)
                newXrMeshes.push(xrMesh);
        });
        const deletedMeshes = [];
        this._meshes.forEach((mesh) => {
            if (!detectedMeshes.has(mesh.xrMesh)) {
                deletedMeshes.push(mesh);
            }
        });
        newXrMeshes.forEach((xrMesh) => {
            const mesh = new Mesh_1.RMesh(xrMesh);
            (0, Mesh_1.updateMesh)(mesh, this._xrManager);
            this._root.add(mesh);
            if (this.onMeshAdded) {
                this.onMeshAdded(mesh);
            }
            this._meshes.add(mesh);
        });
        deletedMeshes.forEach((mesh) => {
            if (this.onMeshDeleted) {
                this.onMeshDeleted(mesh);
            }
            this._root.remove(mesh);
            this._meshes.delete(mesh);
        });
    }
    async createAnchor(position, quaternion, persistent = false) {
        const anchor = await (0, Anchor_1.createAnchorFromTransform)(this._xrManager, position, quaternion);
        this._root.add(anchor);
        this._anchors.add(anchor);
        if (persistent) {
            await anchor.makePersistent();
        }
        return anchor;
    }
    async deleteAnchor(anchor) {
        if (anchor.isPersistent) {
            await (0, Anchor_1.deleteAnchorPersistence)(anchor, this._xrManager);
        }
        this._anchors.delete(anchor);
        this._root.remove(anchor);
        anchor.xrAnchor.delete();
    }
    async restorePersistentAnchors() {
        const session = this._xrManager.getSession();
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        const persistentAnchors = session.persistentAnchors;
        if (!persistentAnchors) {
            throw new DOMException('feature not supported by browser', 'NotSupportedError');
        }
        for (const anchorId of persistentAnchors) {
            const anchor = await (0, Anchor_1.restoreAnchorFromUUID)(this._xrManager, anchorId);
            this._root.add(anchor);
            this._anchors.add(anchor);
        }
    }
    async createHitTestTargetFromSpace(space, offsetOrigin = new three_1.Vector3(0, 0, 0), offsetDirection = new three_1.Vector3(0, 0, -1)) {
        const hitTestTarget = await (0, HitTestTarget_1.createHitTestTargetFromSpace)(this._xrManager, space, offsetOrigin, offsetDirection);
        this._root.add(hitTestTarget);
        this._hitTestTargets.add(hitTestTarget);
        return hitTestTarget;
    }
    async createHitTestTargetFromViewerSpace(offsetOrigin = new three_1.Vector3(0, 0, 0), offsetDirection = new three_1.Vector3(0, 0, -1)) {
        const viewerSpace = await this._xrManager
            .getSession()
            .requestReferenceSpace('viewer');
        return await this.createHitTestTargetFromSpace(viewerSpace, offsetOrigin, offsetDirection);
    }
    async createHitTestTargetFromControllerSpace(handedness, offsetOrigin = new three_1.Vector3(0, 0, 0), offsetDirection = new three_1.Vector3(0, 0, -1)) {
        let xrInputSource = null;
        this._xrManager.getSession().inputSources.forEach((source) => {
            if (source.handedness === handedness) {
                xrInputSource = source;
            }
        });
        if (!xrInputSource)
            throw new DOMException('requested XRInputSource cannot be found', 'NotFoundError');
        return await this.createHitTestTargetFromSpace(xrInputSource.targetRaySpace, offsetOrigin, offsetDirection);
    }
    deleteHitTestTarget(hitTestTarget) {
        hitTestTarget.xrHitTestSource.cancel();
        this._root.remove(hitTestTarget);
        this._hitTestTargets.delete(hitTestTarget);
    }
}
exports.RealityAccelerator = RealityAccelerator;
//# sourceMappingURL=RealityAccelerator.js.map