"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.deleteAnchorPersistence = exports.restoreAnchorFromUUID = exports.createAnchorFromTransform = exports.Anchor = void 0;
const TransformObject_1 = require("./TransformObject");
class Anchor extends TransformObject_1.TransformObject {
    _xrAnchor;
    persistenceDeletionPending = false;
    anchorID;
    constructor(xrAnchor, uuid = null) {
        super(xrAnchor.anchorSpace);
        this._xrAnchor = xrAnchor;
        this.anchorID = uuid;
    }
    get xrAnchor() {
        return this._xrAnchor;
    }
    get isPersistent() {
        return this.anchorID != null;
    }
    async makePersistent() {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        if (!this._xrAnchor.requestPersistentHandle) {
            throw new DOMException('feature not supported by browser', 'NotSupportedError');
        }
        else if (this.isPersistent) {
            throw new DOMException('anchor is already persistent', 'InvalidStateError');
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        this.anchorID = await this._xrAnchor.requestPersistentHandle();
    }
    async makeNonPersistent() {
        this.persistenceDeletionPending = true;
    }
}
exports.Anchor = Anchor;
const createAnchorFromTransform = async (xrManager, position, quaternion) => {
    const frame = xrManager.getFrame();
    const refSpace = xrManager.getReferenceSpace();
    const anchorPose = new XRRigidTransform({
        x: position.x,
        y: position.y,
        z: position.z,
    }, {
        x: quaternion.x,
        y: quaternion.y,
        z: quaternion.z,
        w: quaternion.w,
    });
    const xrAnchor = await frame.createAnchor(anchorPose, refSpace);
    const anchor = new Anchor(xrAnchor);
    return anchor;
};
exports.createAnchorFromTransform = createAnchorFromTransform;
const restoreAnchorFromUUID = async (xrManager, uuid) => {
    const session = xrManager.getSession();
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    if (!session.restorePersistentAnchor) {
        throw new DOMException('feature not supported by browser', 'NotSupportedError');
    }
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const xrAnchor = await session.restorePersistentAnchor(uuid);
    const anchor = new Anchor(xrAnchor, uuid);
    return anchor;
};
exports.restoreAnchorFromUUID = restoreAnchorFromUUID;
const deleteAnchorPersistence = async (anchor, xrManager) => {
    if (anchor.isPersistent) {
        const session = xrManager.getSession();
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        if (!session.deletePersistentAnchor) {
            throw new DOMException('feature not supported by browser', 'NotSupportedError');
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        await session.deletePersistentAnchor(anchor.anchorID);
        anchor.anchorID = null;
    }
};
exports.deleteAnchorPersistence = deleteAnchorPersistence;
//# sourceMappingURL=Anchor.js.map