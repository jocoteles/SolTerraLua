"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateMesh = exports.RMesh = void 0;
const three_1 = require("three");
const TransformObject_1 = require("./TransformObject");
class RMesh extends TransformObject_1.TransformObject {
    _xrMesh;
    needsUpdate = true;
    lastUpdatedByRATK = -Infinity;
    meshMesh;
    boundingRectangleWidth;
    boundingRectangleHeight;
    constructor(xrMesh) {
        super(xrMesh.meshSpace);
        this._xrMesh = xrMesh;
    }
    get xrMesh() {
        return this._xrMesh;
    }
    get lastUpdated() {
        return this._xrMesh.lastChangedTime;
    }
    get semanticLabel() {
        return this._xrMesh.semanticLabel;
    }
}
exports.RMesh = RMesh;
const updateMesh = (mesh, xrManager) => {
    (0, TransformObject_1.updateTransformObject)(mesh, xrManager);
    if (mesh.xrMesh.lastChangedTime <= mesh.lastUpdatedByRATK)
        return;
    const geometry = new three_1.BufferGeometry();
    geometry.setAttribute('position', new three_1.BufferAttribute(mesh.xrMesh.vertices, 3));
    geometry.setIndex(new three_1.BufferAttribute(mesh.xrMesh.indices, 1));
    if (mesh.meshMesh) {
        mesh.meshMesh.geometry.dispose();
        mesh.meshMesh.geometry = geometry;
    }
    else {
        mesh.meshMesh = new three_1.Mesh(geometry, new three_1.MeshBasicMaterial());
        mesh.add(mesh.meshMesh);
    }
    mesh.lastUpdatedByRATK = mesh.xrMesh.lastChangedTime;
};
exports.updateMesh = updateMesh;
//# sourceMappingURL=Mesh.js.map