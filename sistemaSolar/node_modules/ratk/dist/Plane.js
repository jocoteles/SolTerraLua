"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.updatePlane = exports.Plane = void 0;
const three_1 = require("three");
const TransformObject_1 = require("./TransformObject");
class Plane extends TransformObject_1.TransformObject {
    _xrPlane;
    needsUpdate = true;
    lastUpdatedByRATK = -Infinity;
    planeMesh;
    boundingRectangleWidth;
    boundingRectangleHeight;
    constructor(xrPlane) {
        super(xrPlane.planeSpace);
        this._xrPlane = xrPlane;
    }
    get xrPlane() {
        return this._xrPlane;
    }
    get orientation() {
        return this._xrPlane.orientation;
    }
    get lastUpdated() {
        return this._xrPlane.lastChangedTime;
    }
}
exports.Plane = Plane;
const createGeometryFromPolygon = (polygon) => {
    const planeShape = new three_1.Shape();
    polygon.forEach((point, i) => {
        if (i == 0) {
            planeShape.moveTo(point.x, point.z);
        }
        else {
            planeShape.lineTo(point.x, point.z);
        }
    });
    const geometry = new three_1.ShapeGeometry(planeShape);
    geometry.rotateX(-Math.PI / 2);
    return geometry;
};
const calculateBoundingRectangleDimension = (polygon) => {
    let minx = Infinity;
    let minz = Infinity;
    let maxx = -Infinity;
    let maxz = -Infinity;
    polygon.forEach((point) => {
        minx = Math.min(minx, point.x);
        minz = Math.min(minz, point.z);
        maxx = Math.max(maxx, point.x);
        maxz = Math.max(maxz, point.z);
    });
    return [maxx - minx, maxz - minz];
};
const updatePlane = (plane, xrManager) => {
    (0, TransformObject_1.updateTransformObject)(plane, xrManager);
    if (plane.xrPlane.lastChangedTime <= plane.lastUpdatedByRATK)
        return;
    const planeGeometry = createGeometryFromPolygon(plane.xrPlane.polygon);
    if (plane.planeMesh) {
        plane.planeMesh.geometry.dispose();
        plane.planeMesh.geometry = planeGeometry;
    }
    else {
        plane.planeMesh = new three_1.Mesh(planeGeometry, new three_1.MeshBasicMaterial());
        plane.add(plane.planeMesh);
    }
    [plane.boundingRectangleWidth, plane.boundingRectangleHeight] =
        calculateBoundingRectangleDimension(plane.xrPlane.polygon);
    plane.lastUpdatedByRATK = plane.xrPlane.lastChangedTime;
};
exports.updatePlane = updatePlane;
//# sourceMappingURL=Plane.js.map